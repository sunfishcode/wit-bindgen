#![allow(unused_macros)]

mod codegen_tests {
    macro_rules! codegen_test {
        ($id:ident $name:tt $test:tt) => {
            mod $id {
                wit_bindgen::generate!({
                    path: $test,
                    stubs
                });

                // This empty module named 'core' is here to catch module path
                // conflicts with 'core' modules used in code generated by the
                // wit_bindgen::generate macro.
                // Ref: https://github.com/bytecodealliance/wit-bindgen/pull/568
                mod core {}

                #[test]
                fn works() {}

                mod duplicate {
                    wit_bindgen::generate!({
                        path: $test,
                        ownership: Borrowing {
                            duplicate_if_necessary: true
                        },
                        stubs,
                        export_prefix: "[duplicate]",
                    });

                    #[test]
                    fn works() {}
                }
            }

        };
    }
    test_helpers::codegen_tests!();
}

mod strings {
    wit_bindgen::generate!({
        inline: "
            package my:strings

            world not-used-name {
                import cat: interface {
                    foo: func(x: string)
                    bar: func() -> string
                }
            }
        ",
    });

    #[allow(dead_code)]
    fn test() {
        // Test the argument is `&str`.
        cat::foo("hello");

        // Test the return type is `String`.
        let _t: String = cat::bar();
    }
}

/// Like `strings` but with raw_strings`.
mod raw_strings {
    wit_bindgen::generate!({
        inline: "
            package my:raw-strings

            world not-used-name {
                import cat: interface {
                    foo: func(x: string)
                    bar: func() -> string
                }
            }
        ",
        raw_strings,
    });

    #[allow(dead_code)]
    fn test() {
        // Test the argument is `&[u8]`.
        cat::foo(b"hello");

        // Test the return type is `Vec<u8>`.
        let _t: Vec<u8> = cat::bar();
    }
}

mod skip {
    wit_bindgen::generate!({
        inline: "
            package my:inline

            world baz {
                export exports: interface {
                    foo: func()
                    bar: func()
                }
            }
        ",
        skip: ["foo"],
        interface_exports: {
            "exports": Component
        }
    });

    struct Component;

    impl exports::exports::Exports for Component {
        fn bar() {}
    }
}

mod symbol_does_not_conflict {
    wit_bindgen::generate!({
        inline: "
            package my:inline

            interface foo1 {
                foo: func()
            }

            interface foo2 {
                foo: func()
            }

            interface bar1 {
                bar: func() -> string
            }

            interface bar2 {
                bar: func() -> string
            }


            world foo {
                export foo1
                export foo2
                export bar1
                export bar2
            }
        ",
        interface_exports: {
            "my::inline::foo1": Component,
            "my::inline::foo2": Component,
            "my::inline::bar1": Component,
            "my::inline::bar2": Component
        }
    });

    struct Component;

    impl exports::my::inline::foo1::Foo1 for Component {
        fn foo() {}
    }

    impl exports::my::inline::foo2::Foo2 for Component {
        fn foo() {}
    }

    impl exports::my::inline::bar1::Bar1 for Component {
        fn bar() -> String {
            String::new()
        }
    }

    impl exports::my::inline::bar2::Bar2 for Component {
        fn bar() -> String {
            String::new()
        }
    }
}
